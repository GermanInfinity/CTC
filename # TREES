# TREES
# in-order successor
# if i have right child, return leftmost right child
# find best parent

# get height of a binary tree 
# max(left, right) + 1..return 0 if none

# check if tree is balanced 
# check node is balanced, 
# if node is balanced, check left, check right, return true 
# return false

# Correct BST
# Get inorder traversal of elements in tree
# sort list
# insert back in to the tree

# connect nodes at same level 
# use deque, put all node in list of lists
# connect them with right pointer 
# 116. Populating Next Right Pointers in Each Node

# Validate BST
# remember to treat each node like a subtree
# remember to use helper function, so we can pass in max and min values
# max is inf min is -inf
# check node doesnt violate with max and min, return anded result of left and right
# change max_value and min_value in left and right function calls. 

# find closest value in BST
# use helper function to allow passing of closest value 
# use while loop to move through tree, 
# have condition to update closest value
# return closest value

# get sum of all paths in tree and store in array
# handle each node as subtree
# at each node increase sum
# when at leaf append your path list with sum
# call on left and right
# return path


# GET PATH FROM ROOT TO LEAF- path sum II
# keep track of list 
# it's normal add nodes till leaf, at leaf add list to big list and return
# at end, in recursive call. pass copy of list, instead of actual leaf!

#  i can get paths in a string, the normal algoexpert way, when at leaf just append
to array
# it can also be the total of the path as well. 


# GET ALL LEVELS OF TREE
# use a queue
# initialize level list
# set up for loop till size of queue
# append to level, and inspect left and right children
# append result outside of for loop 
# 


# lowwest common ancestor
# moving only one pointer if both p and q are less or greater than 
# if they disagree in inequality return the ptr

